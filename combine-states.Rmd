---
title: "SRF PPL & IUP Standardization"
author: "Walker Grimshaw & Phil Cork"
date: "2022-12-20"
output: pdf_document
geometry: margin=2.54cm
editor_options: 
  chunk_output_type: console
---

This notebook imports the individual cleaning functions for each state and each year to create the final, standardized project-level dataset that powers the SRF Funding Tracker website and saves the results to AWS.

# Settings & Imports

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# remove any dfs in the environment before starting
rm(list=ls())

source("resources/inputs.R")
run_code_from_file("aws.txt")

source("resources/cleaning.R")
source("resources/testing.R")

```


# Import Clean State Data

```{r clean_state_data}

## State vector with 15 focus states, currently in new lines to allow for commenting out ----
states <- c(
  "AL", 
  #"AR",
  #"IL", 
  "IN",   
  "LA",
  "MI", 
  #"MN", 
  "MS",
  #"NJ", 
  "NY", 
  #"OH", 
  #"PA",
  "TN", 
  "TX"
  #, 
  #"WI"
  )

## Years vector with 5 years, currently in new lines to allow for commenting out ----
years <- c(
  0,
  1,
  2,
  3,
  4,
  5
  )

for (year in years) {
  for (state in states) {
    skip_to_next <- FALSE
    
    message(glue::glue("Processing year: {year}, state: {state}"))

    # Build path to script
    script_path <- glue::glue("year{year}/{state}/code/clean-{state}.R")

    # Try to source the file
    tryCatch({
      # Source file
      source(script_path)
    }, error = function(e) {
      message(glue::glue("❌ Failed to source: {script_path} — {e$message}"))
      skip_to_next <<- TRUE  # Skip to the next iteration
    })
    
    if(skip_to_next) { next }  

    # Try to call the cleaning function and assign the result
    tryCatch({
      
      # Dynamically build and call the function
      func_call <- rlang::parse_expr(glue::glue("clean_{stringr::str_to_lower(state)}_y{year}()"))
      
      result <- eval(func_call)
      
      # Assign result to dynamic name
      assign(
        glue::glue("{stringr::str_to_lower(state)}_clean_y{year}"),
        result,
        envir = .GlobalEnv
      )
    }, error = function(e) {
      message(glue::glue("❌ Failed to run function for {state} in year {year} — {e$message}"))
      # Continue to next state/year
    })
  }
}

rm(result)

```

# Post-Process

## Combine & Format States

```{r}
# create a list of all objects and boolean for whether each object is a dataframe
dfs <- sapply(.GlobalEnv, is.data.frame) 
# for each TRUE, add the dataframe rows to a single data.frame
combined_clean <- do.call(bind_rows, mget(names(dfs)[dfs]))

```

```{r}

# Writing to temp
write.csv(combined_clean, file.path(tempdir(), "dwsrf-funding-tracker-all-projects.csv"), row.names = FALSE)

#Putting in Bucket
put_object(
  file = file.path(tempdir(), "dwsrf-funding-tracker-all-projects.csv"),
  object = "clean_data/srf_project_priority_lists/dwsrf-funding-tracker-all-projects.csv",
  bucket = "water-team-data",
  acl = "public-read"
)
```

```{r}
```